# 데이터 모델과 성능
  ## 정규화(Normalization)
  * 정규화는 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법이며 데이터를 분해하는 과정이다.
  * 정규화는 데이터의 중복을 제거하고 데이터 모델의 독립성을 확보하기 위한 방법이다.
  * 정규화를 수행하면 비즈니스에 변화가 발생하여도 데이터 모델의 변경을 최소화할 수 있다.
  * 정규화는 제5 정규화까지 있지만, 실질적으로는 제3정규화까지만 수행한다.
  * 정규화된 모델은 테이블이 분해된다. 테이블이 분해되면 직원 테이블과 부서 테이블 간에 부서코드로 조인(Join)을 수행하여 하나의 합집합으로 만들 수도 있다.
  * 정규화를 수행하면 불필요한 데이터를 입력하지 않아도 되기 때문에 중복 데이터가 제거된다.
  
  ### 정규화 절차
  #### 제1정규화
    - 속성의 원자성을 확보한다.
    - 기본키를 설정한다.
  #### 제2정규화
    - 기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성을 제거(분해)한다.
  #### 제3정규화
    - 기본키를 제외한 칼럼 간의 종속성을 제거한다.
    - 즉, 이행 함수 종속성을 제거한다.
  #### BCNF
    - 기본키를 제외하고 후보키가 있는 경우, 후보키가 기본키를 종속시키면 분해한다.
  #### 제4정규화
    - 여러 칼럼들이 하나의 칼럼을 종속시키는 경우 분해하여 다중값 종속성을 제거한다.
  #### 제5정규화
    - 조인에 의해서 종속성이 발생되는 경우 분해한다.
  
  ## 함수적 종속성(Functional Dependency)
  ### 제1정규화
    * 정규화는 함수적 종속성을 근거로 한다. 함수적 종속성이란 X->Y이면 Y는 X에 함수적으로 종속된다고 말한다.
    * 함수적 종속성은 X가 변화되면 Y도 변화되는지 확인한다. 
      예를 들어 회원ID가 변화하면 이름도 변경될 것이다. 이런 경우는 회원 ID가 기본키가 되고, 회원 ID가 이름을 함수적으로 종속한다고 한다.
  ### 제2정규화
    * 부분 함수 종속성이란, 기본키가 2개 이상의 칼럼으로 이루어진 경우에만 발생한다.
    * 기본키가 하나의 칼럼으로 이루어지면 제2정규화는 생략한다.
  ### 제3정규화
    * 제3정규화는 이행 함수 종속성을 제거한다. 이행 함수 종속성이란, 기본키를 제외하고 칼럼 간의 종속성이 발생하는 것이다.
    * 제3정규화는 제1정규화와 제2정규화를 수행한 다음에 해야 한다.
  ### BCNF(Boyce-Codd Normal Form)
    * BCNF는 복수의 후보키가 있고, 후보키들이 복합 속성이어야 하며, 서로 중첩되어야 한다.
  
  ## 정규화와 성능
  ### 정규화의 문제점
    * 정규화는 테이블을 분해해서 데이터 중복을 제거하기 때문에 데이터 모델의 유연성을 높인다.
    * 정규화는 데이터 조회 시에 Join을 유발하기 때문에 CPU와 메모리를 많이 사용한다.
    * 정규화의 문제점을 해결하기위해 Index와 Optimizer가 있는 것이다.
    * 정규화의 문제점을 해결하기 위해서 반정규화를 하여 하나의 테이블에 저장한다면 조인을 통한 성능 저하는 해결될 것이다.
  ### 정규화를 사용한 성능 튜닝
    * 반정규화로 너무 많은 칼럼이 추가되면 한 개 행의 크기가 데이터베이스 관리 시스템의 입출력 단위인 블록의 크기를 넘어서게 된다.
    * 그렇게 되면 한 개의 행을 읽기 위해서 여러 개의 블록을 읽어야 한다. -> 디스크 입출력 증가
    * 테이블 분해를 통해 입출력 데이터의 양을 줄여서 성능을 향상시켜야 한다. -> 정규화
  
  ## 반정규화
  ### 반정규화
    * 데이터베이스 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법이다.
    * 반정규화는 조회 속도를 향상하지만, 데이터 모델의 유연성은 낮아진다.
  ### 반정규화를 수행하는 경우
    * 정규화에 충실하면 종속성, 활용성은 향상되지만 수행 속도가 느려지는 경우
    * 다량의 범위를 자주 처리해야 하는 경우
    * 특정 범위의 데이터만 자주 처리하는 경우
    * 요약/집계 정보가 자주 요구되는 경우
  #### 반정규화 절차
    - 대상 조사 및 검토
      -- 데이터 처리 범위, 통계성 등을 확인해서 반정규화 대상을 조사한다.
    - 다른 방법 검토
      -- 반정규화를 수행하기 전에 다른 방법이 있는지 검토한다.
      -- 예를 들어 클러스터링, 뷰, 인덱스 튜닝, 응용 프로그램, 파티션 등을 검토한다.
    - 반정규화 수행
      -- 테이블, 속성, 관계 등을 반정규화 한다.
  #### 클러스터링
    * 클러스터링 인덱스라는 것은 인덱스 정보를 저장할 때 물리적으로 정렬해서 저장하는 방법이다.
    * 따라서 **조회 시에 인접 블록을 연속적으로 읽기 때문에 성능이 향상된다.**
  ### 반정규화 기법
    1. 계산된 칼럼 추가
      * 배치 프로그램으로 총판매액, 평균잔고, 계좌평가 등을 미리 계산하고, 그 결과를 특정 칼럼에 추가한다.
    2. 테이블 수직분할
      * 하나의 테이블을 두 개 이상의 테이블로 분할한다. 즉, 칼럼을 분할하여 새로운 테이블을 만드는 것이다.
    3. 테이블 수평분할
      * 하나의 테이블에 있는 값을 기준으로 테이블을 분할하는 방법이다.
    4. 테이블 병합
      * 1대1 관계의 테이블을 하나의 테이블로 병합해서 성능을 향상시킨다.
      * 1대N 관게의 테이블을 병합하여 성능을 향상시킨다. 하지만 많은 양의 데이터 중복이 발생한다.
      * 슈퍼 타입과, 서브 타입 관계가 발생하면 테이블을 통합하여 성능을 향상시킨다.
  
  #### 슈퍼 타입과 서브 타입
    * 고객 엔터티는 개인고객과 법인고객으로 분류된다. 이때 고객 엔터티는 슈퍼 타입이고 개인고객과 법인고객은 서브 타입이 된다.
    * 즉, 부모와 자식 간의 관계가 나타난다.
    * 슈퍼 타입과 서브 타입의 관계는 베타적 관계와 포괄적 관계가 있는데, 베타적 관계는 고객이 개인고객이거나 법인고객인 경우를 의미한다.
      포괄적 관계는 고객이 개인고객일 수도 있고 법인고객일 수도 있는 것이다.
  #### 슈퍼 타입과 서브 타입 변환 방법
  ##### OneToOne Type
    - 슈퍼 타입과 서브 타입을 개별 테이블로 도출한다.
    - 테이블의 수가 많아서 조인이 발생하고 관리가 어렵다.
  ##### Plus Type
    - 슈퍼 타입과 서브 타입 테이블로 도출한다.
    - 조인이 발생하고 관리가 어렵다.
  ##### Single Type
    - 슈퍼 타입과 서브 타입을 하나의 테이블로 도출한다.
    - 조인 성능이 좋고 관리가 편리하지만, 입출력 성능이 나쁘다.
    
  #### 파티션 기법
    * 데이터베이스에서 파티션을 사용하여 테이블을 분할할 수 있다. 파티션을 사용하면 논리적으로는 하나의 테이블이지만
    여러 개의 데이터 파일에 분산되어서 저장된다.
    * Range Partition : 데이터 값의 범위를 기준으로 파티션을 수행한다.
    * List Partition : 특정한 값을 지정하여 파티션을 수행한다.
    * Hash Partition : 해시 함수를 적용하여 파티션을 수행한다.
    * Composite Partition : 범위와 해시를 복합적으로 사용하여 파티션을 수행한다.
  #### 파티션 테이블의 장점
    * 데이터 조회 시에 엑세스 범위가 줄어들기 때문에 성능이 향상된다.
    * 데이터가 분할되어 있기 때문에 I/O 성능이 향상된다.
    * 각 파티션을 독립적으로 백업 및 복구가 가능하다.
    
  ## 분산 데이터베이스
  ### 분산 데이터베이스
    * 데이터베이스 시스템 구축 시에 한 대의 물리적 시스템에 데이터베이스 관리 시스템을 설치하고 여러 명의
      사용자가 데이터베이스 관리 시스템에 접속하여 데이터베이스를 사용하는 구조를 중앙 집중형 데이터베이스라고 한다.
    * 또한 물리적으로 떨어진 데이터베이스에 네트워크로 연결하여 단일 데이터베이스 이미지를 보여주고 분산된
      작업 처리를 수행하는 데이터베이스를 분산 데이터베이스라고 한다.
    * 분산 데이터베이스를 사용하는 고객은 시스템이 네트워크로 분산되어 있는지의 여부를 인식하지 못하면서, 자신만의
      데이터베이스를 사용하는 것처럼 사용할 수 있다. 이처럼 데이터베이스는 투명성을 제공해야 한다.
    * 투명성은 분산 데이터베이스에서 중요한 요소이며 투명성의 종류에는 분할, 위치, 지역사상, 중복, 장애 및 병행 투명성이 있다.
  ### 분산 데이터베이스의 투명성 종류
  #### 분할 투명성
    - 고객은 하나의 논리적 릴레이션이 여러 단편으로 분할되어 각 단편의 사본이 여러 시스템에 저장되어 있음을 인식할 필요가 없다.
  #### 위치 투명성
    - 고객이 사용하려는 데이터의 저장 장소를 명시할 필요가 없다.
    - 고객은 데이터가 어느 위치에 있더라도 동일한 명령을 사용하여 데이터에 접근할 수 있어야 한다.
  #### 지역 사상 투명성
    - 지역 DBMS 의 물적 데이터베이스 사이의 사상이 보장됨에 따라 각 지역 시스템 이름과 무관한 이름이 사용 가능하다.
  #### 중복 투명성
    - 데이터베이스 객체가 여러 시스템에 중복되어 존재함에도 고객과는 무관하게 데이터의 일관성이 유지된다.
  #### 장애 투명성
    - 데이터베이스가 분산되어 있는 각 지역의 시스템이나 통신마엥 이상이 발생해도, 데이터의 무결성은 보장된다.
  #### 병행 투명성
    - 여러 고객의 응용 프로그램이 동시에 분산 데이터베이스에 대한 트랜잭션을 수행하는 경우에도 결과에 이상이 없다.
  
  ### 분산 데이터베이스 설계 방식
    * 분산 데이터베이스의 구축 방법에는 상향식 설계 방법과 하향식 설계 방식 2가지가 있다.
  #### 상향식 설계 방식
    지역 스키마가 작성 후 향후 전역 스키마를 작성하여 분산 데이터베이스를 구축한다.
  #### 하향식 설계 방식
    전역 스키마 작성 후 해당 지역 사상 스키마를 작성하여 분산 데이터베이스를 구축한다.
  * 분산 데이터베이스를 구축하거나 운영할 때 동일한 데이터베이스 관리 시스템으로 분산 데이터베이스를 구축하는 것은 크게 어렵지 않다.
  하지만 기업에 여러 종류의 데이터베이스 관리 시스템이 있으면 이기종 데이터베이스 관리 시스템으로 연동해야 한다. 이기종 데이터베이스
  시스템으로 연동하기 위해서는 데이터베이스 미들웨어(ODBC, JDBC)를 사용해야 한다.
  
  ### 분산형 데이터베이스 장점과 단점
  #### 장점
    - 데이터 베이스 신뢰성과 가용성이 높다.
    - 병렬 처리를 수행하기 떄문에 빠른 응답이 가능하다.
    - 용량 확장이 쉽다.
  #### 단점
    - 여러 네트워크를 통해서 분리되어 있기 때문에 관리와 통제가 어렵다.
    - 보안관리가 어렵다.
    - 데이터 무결성 관리가 어렵다.
    - 데이터베이스 설계가 복잡하다.
  
